<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Required meta tags -->


<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>NanoGPT Speedrun Living Worklog</title>
<meta name="author" content="Tyler Romero">
<meta name="description" content="How fast can I train GPT-2 on two RTX 4090 GPUs?">
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/assets/img/favicon.ico" type="image/ico">
<link rel="canonical" href="https://www.tylerromero.com/posts/nanogpt-speedrun-worklog/">
<link type="application/atom+xml" rel="alternate" href="https://www.tylerromero.com/feed.xml" title="Tyler&#39;s Technical Blog">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="/assets/et-book/et-book-roman-line-figures/et-book-roman-line-figures.woff">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="/assets/et-book/et-book-display-italic-old-style-figures/et-book-display-italic-old-style-figures.woff">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="/assets/et-book/et-book-bold-line-figures/et-book-bold-line-figures.woff">
<link rel="preload" as="font" type="font/woff2" crossorigin="" href="/assets/et-book/et-book-roman-old-style-figures/et-book-roman-old-style-figures.woff">


<!-- KaTeX Support -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<!-- BibTeX Support -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/pcooksey/bibtex-js@1.0.0/src/bibtex_js.min.js"></script>
<!-- Stylesheets -->
<link rel="stylesheet" href="/assets/tufte.min.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css">
<!-- Goat Counter for basic view counting w/o cookies -->
<script data-goatcounter="https://tylerromero.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>

        <script type="application/ld+json">
            {
            "@context": "https://schema.org",
            "@type": "BlogPosting",
            "headline": "NanoGPT Speedrun Living Worklog",
            "description": "How fast can I train GPT-2 on two RTX 4090 GPUs?",
            "author": {
                "@type": "Person",
                "name": "Tyler Romero",
                "url": "https://www.tylerromero.com"
            },
            "datePublished": "2025-03-08T08:00:00.000Z",
            "dateModified": "2025-05-03T18:23:02.400Z",
            "url": "https://www.tylerromero.com/posts/nanogpt-speedrun-worklog/",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://www.tylerromero.com/posts/nanogpt-speedrun-worklog/"
            },
            "image": "https://www.tylerromero.com",
            "keywords": "post, llm, gpt2, speedrun, nanogpt, worklog, muon",
            "wordCount": "3536",
            "articleBody": "I’ve seen some really awesome GPT-2 speedrun results from people like Keller Jordan, Fern, Braden Koszarsky, and others. I got a little inspired and wanted to see how fast I could train GPT-2 on my own hardware. Technically, the NanoGPT speedrun is to train a neural network to 3.28 validation loss on FineWeb as fast as possible on an 8xH100 node. Keller Jordan maintains a leaderboard here. At the time of writing (Jan 16, 2025), the record is 3.14 minutes (!). I have access to 2xRTX 4090 GPUs and..."
            }
        </script>
    </head>
    <header>
        <nav class="topbar">
            <div class="right-aligned-links">
                <a href="/" class="no-tufte-underline" style="color: #246eb9;
                          margin-right: 3%">Tyler Romero</a>
                <a href="/#posts" class="no-tufte-underline">posts</a>
                <span class="desktop-only">
                    <a href="/#projects" class="no-tufte-underline">projects</a>
                    <a href="/#reading-list" class="no-tufte-underline">reading list</a>
                </span>
            </div>
        </nav>
    </header>
    <body>
        <article>
            <h1>NanoGPT Speedrun Living Worklog
</h1>
            <p class="subtitle">How fast can I train GPT-2 on two RTX 4090 GPUs?
</p>
            <p class="date">March 8, 2025</p>
            <section><p>I’ve seen <a href="https://x.com/kellerjordan0/status/1859331370268623321">some</a> <a href="https://x.com/kellerjordan0/status/1842300916864844014">really</a> <a href="https://x.com/kellerjordan0/status/1876048851158880624">awesome</a> <a href="https://x.com/hi_tysam/status/1879687807678959729">GPT-2</a> speedrun results from people like <a href="https://x.com/kellerjordan0">Keller Jordan</a>, <a href="https://x.com/hi_tysam">Fern</a>, <a href="https://x.com/KoszarskyB">Braden Koszarsky</a>, and others. I got a little inspired and wanted to see how fast I could train GPT-2 on my own hardware.</p><p>Technically, <a href="https://x.com/kellerjordan0/status/1798863559243513937">the NanoGPT speedrun</a> is to train a neural network to 3.28 validation loss on FineWeb as fast as possible on an 8xH100 node. <a href="https://github.com/KellerJordan/modded-nanogpt?tab=readme-ov-file#world-record-history">Keller Jordan maintains a leaderboard here</a>. At the time of writing (Jan 16, 2025), the record is 3.14 minutes (!).</p><p>I have access to <strong>2xRTX 4090 GPUs</strong> and I want to see how fast I can train GPT-2 on them by following the same rules as the NanoGPT speedrun. If I see some success, I may try to transfer my methods to an 8xH100 node for comparison with the main leaderboard.</p><p>I’ll be documenting my progress here and updating this post as I go. Code can be found in <a href="https://github.com/tyler-romero/nanogpt-speedrun">this GitHub repo</a>.</p></section>
<section><h2 id="progress-so-far">Progress so far</h2><table>
<thead>
<tr>
<th align="left">#</th>
<th align="left">Description</th>
<th align="left">Record time</th>
<th align="left">Training Tokens</th>
<th align="left">Tokens/Second</th>
<th align="left">Date</th>
<th align="left">Commit</th>
<th align="left">Log</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><a href="#1-initial-setup-and-baseline">1</a></td>
<td align="left">Initial baseline</td>
<td align="left">8.13 hours</td>
<td align="left">6.44B</td>
<td align="left">221k</td>
<td align="left">2025/01/16</td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/b3c32f8937c1f4655c5eb9607970e03e351a6c08">b3c32f8</a></td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/blob/main/logs/4c627c0d-029c-4f8a-bd18-40f99b43b22e.txt">here</a></td>
</tr>
<tr>
<td align="left"><a href="#21-architectural-changes-and-training-tweaks">2.1</a></td>
<td align="left">Architectural changes</td>
<td align="left">7.51 hours</td>
<td align="left">5.07B</td>
<td align="left">188k</td>
<td align="left">2025/01/18</td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/b7bb93fd988d73a55184c553f0020feec1454340">b7bb93f</a></td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/blob/main/logs/14fcdb07-443d-4d1c-b307-061bc4bd2cd6.txt">here</a></td>
</tr>
<tr>
<td align="left"><a href="#22-muon-optimizer">2.2</a></td>
<td align="left">Muon optimizer</td>
<td align="left">4.53 hours</td>
<td align="left">3.04B</td>
<td align="left">187k</td>
<td align="left">2025/01/23</td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/b91c2c00673b125944abde277dd5ef3dc141284d">b91c2c0</a></td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/blob/main/logs/59951c17-fbe5-4577-a1bc-6dc0c1802d2e.txt">here</a></td>
</tr>
<tr>
<td align="left"><a href="#23-dataloading-tweaks">2.3</a></td>
<td align="left">Dataloading tweaks</td>
<td align="left">4.26 hours</td>
<td align="left">3.31B</td>
<td align="left">216k</td>
<td align="left">2025/02/18</td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/d59944dbe8535fea8ea107d9a6fb133de5346de5">d59944d</a></td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/blob/main/logs/08047f73-cb01-4f47-a901-de901b2a6b6e.txt">here</a></td>
</tr>
<tr>
<td align="left"><a href="#24-logit-soft-capping">2.4</a></td>
<td align="left">Logit Soft-capping at 30</td>
<td align="left">4.01 hours</td>
<td align="left">3.15B</td>
<td align="left">218k</td>
<td align="left">2025/02/23</td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/12eab44ca1bce8783a3b4d43bfef357eff1a652e">12eab44</a></td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/blob/main/logs/2dbf7fa6-561c-49bc-8aae-665fefdd9a44.txt">here</a></td>
</tr>
<tr>
<td align="left"><a href="#3-longer-training-and-evaluation-sequence-length">3</a></td>
<td align="left">Longer Sequence Length</td>
<td align="left">2.55 hours</td>
<td align="left">1.88B</td>
<td align="left">205k</td>
<td align="left">2025/03/03</td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/d982ed5900922e43a266c5d671b88f36efe72aaf">d982ed5</a></td>
<td align="left"><a href="https://github.com/tyler-romero/nanogpt-speedrun/blob/main/logs/cf1ef5f9-9f79-4798-9360-2b174d8eb25f.txt">here</a></td>
</tr>
</tbody>
</table></section>
<section><h2 id="1-initial-setup-and-baseline">1. Initial setup and baseline</h2><p>Part of the goal of this project is for me to learn as I go, so I am going to start at the beginning - with with Andrej Karpathy’s <a href="https://github.com/karpathy/llm.c/blob/7b929300217ff1a974b63791a228928b39b26409/train_gpt2.py">PyTorch GPT-2 trainer</a> from <a href="https://github.com/karpathy/llm.c">llm.c</a>. This is the script that Keller Jordan used for <a href="https://github.com/KellerJordan/modded-nanogpt/tree/master?tab=readme-ov-file#modded-nanogpt">his initial baseline</a>. This trainer is very similar to the NanoGPT trainer with some minor modifications / simplifications (such as no dropout).</p><p>I have upstreamed some QOL improvements and basic tweaks to the training script from Keller’s fork, but have not changed any of the core training / modeling logic. Specifically:</p><ol>
<li>Implemented gradient accumulation so that my 2x24GB GPUs simulate the training experience of a 8xH100 machine.</li>
<li>Increased learning rate to 0.0015 and halved the batch size (total batch size is 262144 - that is bs of <code>32/device * 2 devices * 1024 sequence length * 4 gradient accum steps</code>).</li>
<li>Improved learning rate schedule (linear warmup then linear decay).</li>
<li>Removed all affine scale/bias parameters and switched to RMSNorm.</li>
<li>Padded the vocab size from 50257 to 50304 to make it a multiple of 128 (for better tensor core utilization).</li>
<li>Using Pytorch 2.5.1 (the switch from 2.4 to 2.5 gave ~9% speedup on the 8xH100 leaderboard).</li>
</ol><p>Additionally, I added <code>wandb</code> logging for easy tracking of training progress - optimistically I may need to remove this one day as it slightly increases step time.</p><p>Commit with the initial setup is here: <a href="https://github.com/tyler-romero/nanogpt-speedrun/blob/main/logs/4c627c0d-029c-4f8a-bd18-40f99b43b22e.txt"><code>b3c32f8</code></a>.</p><p>The baseline run time on my 2xRTX 4090 setup is <strong>8.13 hours</strong>.</p><!-- TODO: plot --></section>
<section><h2 id="2-implementing-major-improvements-from-the-8xh100-leaderboard">2. Implementing major improvements from the 8xH100 leaderboard</h2><p>Waiting 8 hours for a result is too slow for effective experimentation, so I’m going to begin by implementing some of the notable improvements from the 8xH100 leaderboard. I’ll start with the most impactful/easiest changes first:</p><ol>
<li>Architectural changes and training tweaks</li>
<li>Muon optimizer</li>
<li>Dataloading tweaks</li>
<li>Logit Softcapping</li>
</ol><h3 id="21-architectural-changes-and-training-tweaks">2.1 Architectural changes and training tweaks</h3><p>There are some basic architectural changes and modernizations that can be made to the model that will speed up training. These changes are general improvements to the transformer decoder architecture that have been generally adopted since the original GPT-2 paper. The changes are:</p><ol>
<li><a href="https://arxiv.org/abs/2104.09864">RoPE (Rotary Positional Embeddings)</a>. There are <a href="https://www.jitx.io/posts/rope-embeddings">many</a> <a href="https://blog.eleuther.ai/rotary-embeddings/">good</a> explanations of RoPE out there so I won’t go into detail here.</li>
<li><a href="https://arxiv.org/pdf/2109.08668">ReLU^2 Activation</a><label for="sd-relu-2-activation" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sd-relu-2-activation" class="margin-toggle"><span class="sidenote">ReLU^2 activation function. <picture><source type="image/webp" srcset="/assets/img/Zn-fTGuzYQ-300.webp 300w, /assets/img/Zn-fTGuzYQ-600.webp 600w, /assets/img/Zn-fTGuzYQ-900.webp 900w, /assets/img/Zn-fTGuzYQ-1920.webp 1920w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/Zn-fTGuzYQ-300.png" alt="Relu Activation plot" width="1920" height="1440" srcset="/assets/img/Zn-fTGuzYQ-300.png 300w, /assets/img/Zn-fTGuzYQ-600.png 600w, /assets/img/Zn-fTGuzYQ-900.png 900w, /assets/img/Zn-fTGuzYQ-1920.png 1920w" sizes="(max-width: 900px) 100vw, 900px"></picture></span>. Many activations that are better than GeLU have been proposed since GPT-2. ReLU^2 is a simple one that has been shown to be effective in decreasing training time required to reach a certain validation loss.</li>
<li>No gradient clipping. Gradient clipping can help stabilize training but it also slows down training. Since we are speed-running, we will remove gradient clipping. This also eliminates a hyperparameter that needs to be tuned.</li>
<li><a href="https://arxiv.org/abs/2405.18392">Trapezoidal learning rate schedule</a>. While cosine learning rate schedules are the de-facto standard, they can be difficult to work with since changing the number of training steps changes the entire schedule. Trapezoidal learning rate schedules are often easier to reason about / tune around, and they have been show to match the performance of cosine schedules.</li>
</ol><p>In addition, learning rate and batch size have been tuned.</p><p>Once again, many of these changes are <a href="https://en.wikipedia.org/wiki/Downstream_(software_development)">downstreamed</a> from the <a href="https://github.com/KellerJordan/modded-nanogpt">modded-nanogpt</a> repository / 8xH100 speedrun. Its not efficient to reinvent the wheel, and I want to get training time down as fast as possible in the beginning.</p><p>After implementing these changes (commit <a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/b7bb93fd988d73a55184c553f0020feec1454340"><code>b7bb93f</code></a>), the new run time is <strong>7.51 hours</strong>. This run was more data-efficient than the baseline, requiring only 5.07B tokens. However, the tokens/second increased, likely due to the larger batch size (more gradient accumulation steps which tends to translate to lower throughput) and the architectural changes, such as the inclusion of RoPE. Once I have a shorter run time, I will be able to tune more effectively and see if I can remove gradient accumulation.</p><p><picture><source type="image/webp" srcset="/assets/img/J9W8EvOzUU-300.webp 300w, /assets/img/J9W8EvOzUU-600.webp 600w, /assets/img/J9W8EvOzUU-900.webp 900w, /assets/img/J9W8EvOzUU-2562.webp 2562w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/J9W8EvOzUU-300.png" alt="Section 2.1 loss plot" width="2562" height="1612" srcset="/assets/img/J9W8EvOzUU-300.png 300w, /assets/img/J9W8EvOzUU-600.png 600w, /assets/img/J9W8EvOzUU-900.png 900w, /assets/img/J9W8EvOzUU-2562.png 2562w" sizes="(max-width: 900px) 100vw, 900px"></picture></p><h3 id="22-muon-optimizer">2.2 Muon Optimizer</h3><p>The <a href="https://kellerjordan.github.io/posts/muon/">Muon Optimizer</a> is a new optimizer developed with and for the NanoGPT speedrun by Jordan et al. It is a variant of SGD with Momentum that applies a postprocessing step to the gradient updates to approximately orthogonalize each update matrix. Muon has <a href="https://kellerjordan.github.io/posts/muon/#why-is-it-good-to-orthogonalize-the-update">some</a> <a href="https://x.com/leloykun/status/1846842883967692926">connections</a> to approximate second-order optimizers<label for="sd-but-are-these" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sd-but-are-these" class="margin-toggle"><span class="sidenote">But are these approximate second-order methods actually second-order? <a href="https://arxiv.org/abs/2409.20325v1">New research</a> suggests that methods like Shampoo and Adam can be viewed as variants of steepest descent under specific norms, and thus are actually first-order methods.</span> like <a href="https://arxiv.org/abs/1802.09568">Shampoo</a>.</p><p>I highly recommend reading the original <a href="https://kellerjordan.github.io/posts/muon/">Muon blog post</a> for more details, as well as checking out the optimizer comparison for GPT-2 speedrunning that Keller Jordan put to gether <a href="https://github.com/KellerJordan/modded-nanogpt/tree/master/records/102924_Optimizers">here</a>. For those interested in a more step-by-step walkthrough of Muon, check out <a href="https://jeremybernste.in/writing/deriving-muon">this excellent post</a> by Jeremy Bernstein.</p><p>Muon is designed to work on <em>Linear</em> layers, so it is not quite a drop-in replacement for AdamW (e.g. it isn’t meant to optimize Embedding layers). However it can be used to optimize all of the hidden layers of our GPT-2 model. The output <code>lm_head</code> layer and the token embeddings will still be optimized with AdamW.</p><p>Just like on the 8xH100 leaderboard, we observe a massive speedup when switching to Muon. The new run time is <strong>4.53 hours</strong>, requiring only 3.04B tokens. The tokens/second is also very similar to the previous run, which is a good sign that we are not losing throughput by switching optimizers.</p><p><picture><source type="image/webp" srcset="/assets/img/OLzSwEFmsl-300.webp 300w, /assets/img/OLzSwEFmsl-600.webp 600w, /assets/img/OLzSwEFmsl-900.webp 900w, /assets/img/OLzSwEFmsl-2562.webp 2562w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/OLzSwEFmsl-300.png" alt="Section 2.2 loss plot" width="2562" height="1612" srcset="/assets/img/OLzSwEFmsl-300.png 300w, /assets/img/OLzSwEFmsl-600.png 600w, /assets/img/OLzSwEFmsl-900.png 900w, /assets/img/OLzSwEFmsl-2562.png 2562w" sizes="(max-width: 900px) 100vw, 900px"></picture></p><h3 id="23-dataloading-tweaks">2.3 Dataloading Tweaks</h3><p>As we have improved our data efficiency via architecture tweaks and an optimizer change, our training throughput has dropped from 221k tokens/second to 187k tokens/second. That is a ~15% drop in throughput. Recovering most of that throughput could provide a significant improvement to our run time. An obvious place to start is with our dataloading and gradient accumulation logic.</p><p>Up until now, we have loaded a full-batch of data on each device and then split that full batch into smaller chunks (micro-batches) for each gradient accumulation step (recall that we are doing 8 accumulation steps per gradient update). We can instead make a minor tweak to our logic to load only the next micro-batch at each step of the dataloader, and then step the dataloader for each gradient accumulation step.</p><p>We also increase our torch version from <code>2.5</code> to <code>2.6</code> (which was recently released), and, in accordance with the <a href="https://github.com/KellerJordan/modded-nanogpt?tab=readme-ov-file#timing-change-after-record-21">new official rules</a> designated on 2025/02/01, we have removed the use of <code>torch._inductor.config.coordinate_descent_tuning</code>.</p><p>These tweak brings our throughput back up to 216k tokens/second. In order to make runs more consistently hit the 3.28 validation loss target<label for="sd-note-that-there-is" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sd-note-that-there-is" class="margin-toggle"><span class="sidenote">Note that there is some variance in the amount of time it takes for a speedrun candidate to run. For a speedrun to be an official record, it must attain a <em>mean</em> validation loss of less than 3.28. I have been a bit lax about this so far because the time difference between runs has been large, and variance relatively small.</span>, we have also slightly increased the total number of training steps, so now 3.31B tokens are consumed. The new run time is <strong>4.26 hours</strong>, and the changes can be found at <a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/d59944dbe8535fea8ea107d9a6fb133de5346de5"><code>d59944d</code></a>.</p><p><picture><source type="image/webp" srcset="/assets/img/k6VycAKAlz-300.webp 300w, /assets/img/k6VycAKAlz-600.webp 600w, /assets/img/k6VycAKAlz-900.webp 900w, /assets/img/k6VycAKAlz-2562.webp 2562w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/k6VycAKAlz-300.png" alt="Section 2.3 loss plot" width="2562" height="1612" srcset="/assets/img/k6VycAKAlz-300.png 300w, /assets/img/k6VycAKAlz-600.png 600w, /assets/img/k6VycAKAlz-900.png 900w, /assets/img/k6VycAKAlz-2562.png 2562w" sizes="(max-width: 900px) 100vw, 900px"></picture></p><p>At this point, we code that can train GPT-2 almost twice as fast as the baseline.</p><h3 id="24-logit-soft-capping">2.4 Logit Soft-capping</h3><p>Logit soft-capping is a technique popularized by <a href="https://storage.googleapis.com/deepmind-media/gemma/gemma-2-report.pdf">Gemma 2</a> and initially used to improve the NanoGPT speedrun by <a href="https://x.com/Grad62304977">@Grad62304977</a>.</p><p>Soft-capping is essentially a smooth and differentiable version of clipping<label for="md-soft-capping-vs" class="margin-toggle ">&#8853;</label><input type="checkbox" id="md-soft-capping-vs" class="margin-toggle"><span class="marginnote">Soft-capping vs Clipping at ±5: <picture><source type="image/webp" srcset="/assets/img/NOzgbhQs-D-300.webp 300w, /assets/img/NOzgbhQs-D-600.webp 600w, /assets/img/NOzgbhQs-D-900.webp 900w, /assets/img/NOzgbhQs-D-1323.webp 1323w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/NOzgbhQs-D-300.png" alt="Soft-capping" width="1323" height="852" srcset="/assets/img/NOzgbhQs-D-300.png 300w, /assets/img/NOzgbhQs-D-600.png 600w, /assets/img/NOzgbhQs-D-900.png 900w, /assets/img/NOzgbhQs-D-1323.png 1323w" sizes="(max-width: 900px) 100vw, 900px"></picture></span>:</p><div class="math"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>softcap(x, cap)</mtext><mo>=</mo><mtext>cap</mtext><mo>⋅</mo><mi>tanh</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mfrac><mtext>x</mtext><mtext>cap</mtext></mfrac><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\text{softcap(x, cap)} = \text{cap} \cdot \tanh\left(\frac{\text{x}}{\text{cap}}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">softcap(x, cap)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">cap</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mop">tanh</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">cap</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></div><p>Logit soft-capping prevents logits from growing excessively large by scaling them to a fixed range, which seems to help improve training dynamics. One could argue that this is imposing an inductive bias - and since we’re in a relatively small model/low data regime that this is helpful.</p><p>After implementing logit soft-capping with a cap of 30 (and doing some learning-rate tuning), the new run time is <strong>4.01 hours</strong>, requiring 3.15B tokens (commit <a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/12eab44ca1bce8783a3b4d43bfef357eff1a652e"><code>12eab44</code></a>). Throughput remained steady at ~218k tokens/second.</p><p><picture><source type="image/webp" srcset="/assets/img/1PFph9-p9J-300.webp 300w, /assets/img/1PFph9-p9J-600.webp 600w, /assets/img/1PFph9-p9J-900.webp 900w, /assets/img/1PFph9-p9J-2562.webp 2562w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/1PFph9-p9J-300.png" alt="Section 2.4 loss plot" width="2562" height="1612" srcset="/assets/img/1PFph9-p9J-300.png 300w, /assets/img/1PFph9-p9J-600.png 600w, /assets/img/1PFph9-p9J-900.png 900w, /assets/img/1PFph9-p9J-2562.png 2562w" sizes="(max-width: 900px) 100vw, 900px"></picture></p></section>
<section><h2 id="3-longer-training-and-evaluation-sequence-length">3 Longer Training and Evaluation Sequence Length</h2><p>So far, we’ve been training and evaluating on sequences of 1024 tokens. We also haven’t been particularly clever about how those sequences are processed. At each step, we simply load the next 1024 tokens into an element of the batch without regard for where the document starts or stops. That means much of the time we are starting in the middle of a document and cutting that document off before it reaches its end. We are also attending to tokens <em>across documents</em> since we’re just using a simple causal mask.</p><p>Cutting off documents in the middle is an especially large issue. See this plot of average loss vs sequence position:
<picture><source type="image/webp" srcset="/assets/img/P0eirmJcqD-300.webp 300w, /assets/img/P0eirmJcqD-600.webp 600w, /assets/img/P0eirmJcqD-900.webp 900w, /assets/img/P0eirmJcqD-2524.webp 2524w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/P0eirmJcqD-300.png" alt="Average Loss vs Sequence Position" width="2524" height="1658" srcset="/assets/img/P0eirmJcqD-300.png 300w, /assets/img/P0eirmJcqD-600.png 600w, /assets/img/P0eirmJcqD-900.png 900w, /assets/img/P0eirmJcqD-2524.png 2524w" sizes="(max-width: 900px) 100vw, 900px"></picture></p><p>Notice how the first twenty-five or so positions have a much higher average loss than the later positions. This is because at the beginning of the sequence the LLM has much less information with which to make informed predictions about the next token in the sequence. We want to avoid needlessly restarting documents/sequences in order to avoid this loss penalty!</p><p>A natural question to ask at this point is: how long are sequences in our dataset, on average?
<picture><source type="image/webp" srcset="/assets/img/XTDofjqWvO-300.webp 300w, /assets/img/XTDofjqWvO-600.webp 600w, /assets/img/XTDofjqWvO-900.webp 900w, /assets/img/XTDofjqWvO-2635.webp 2635w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/XTDofjqWvO-300.png" alt="Sequence Length CDF Plot" width="2635" height="1658" srcset="/assets/img/XTDofjqWvO-300.png 300w, /assets/img/XTDofjqWvO-600.png 600w, /assets/img/XTDofjqWvO-900.png 900w, /assets/img/XTDofjqWvO-2635.png 2635w" sizes="(max-width: 900px) 100vw, 900px"></picture></p><p>The data reveals that approximately 20% of documents exceed our current 1024 token sequence length. By increasing the sequence length to >=8192 tokens, we can accommodate virtually all documents in our dataset without truncation.</p><p>To address the issues identified above, we’ll implement two key improvements. First, we’ll extend our sequence length to minimize document splitting across sequence boundaries. Taking this approach to its logical conclusion, we’ll eliminate the traditional batch dimension entirely and instead maximize sequence length (effectively using a “batch size” of 1 that contains multiple concatenated documents). Second, we’ll implement sophisticated attention masking that prevents cross-document attention while simultaneously leveraging the computational efficiency of sparse attention patterns.</p><p>Fortunately, <a href="https://pytorch.org/blog/flexattention/">FlexAttention</a> provides an elegant solution that maintains the performance benefits of <a href="https://huggingface.co/docs/text-generation-inference/en/conceptual/flash_attention">FlashAttention</a> while enabling these improvements. One of FlexAttention’s primary strengths is its ability to efficiently handle sparse, custom attention masks, making it ideal for our use case.</p><p>To implement FlexAttention, we need to define an appropriate attention mask that handles our specific requirements:</p><pre><code class="language-python">def make_attn_mask(idx, eot_token, window_size=1024):
    # Create a causal mask (only attend to past tokens)
    def causal_mask(b, h, q_idx, kv_idx):
        return q_idx >= kv_idx

    # Track document boundaries using end-of-text tokens
    documents = (idx == eot_token).cumsum(dim=1)

    # Only allow attention within the same document
    def document_mask(b, h, q_idx, kv_idx):
        return documents[b, q_idx] == documents[b, kv_idx]

    # Limit attention to an N-token window for efficiency
    def sliding_window_mask(b, h, q_idx, kv_idx):
        return q_idx - kv_idx &#x3C;= window_size

    return and_masks(document_mask, causal_mask, sliding_window_mask)
</code></pre><p>Let’s break down each mask:</p><ol>
<li>
<p><strong>Causal Mask</strong>: Standard in autoregressive language modeling. Ensures that tokens can only attend to previous tokens in the sequence, preventing information leakage from future tokens.</p>
</li>
<li>
<p><strong>Document Mask</strong>: This restricts attention to tokens within the same document. By tracking document boundaries using end-of-text tokens, we prevent tokens from attending across different documents, which helps the model maintain coherent context within a single document.</p>
</li>
<li>
<p><strong>Sliding Window Mask</strong>: This limits attention to a fixed window of tokens before the current position. This approach balances efficiency with context retention with a clear tradeoff: smaller windows are more efficient but may miss long-range dependencies, while larger windows capture more context at the expense of resources.</p>
</li>
</ol><p>In order to build intuition about the individual component masks, we visualize them below:
<picture><source type="image/webp" srcset="/assets/img/uDmVV2eE7Z-300.webp 300w, /assets/img/uDmVV2eE7Z-600.webp 600w, /assets/img/uDmVV2eE7Z-900.webp 900w, /assets/img/uDmVV2eE7Z-1273.webp 1273w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/uDmVV2eE7Z-1273.svg" alt="Causal, Document, Sliding Window Attention Masks" width="1273" height="467"></picture></p><p>When combined with the <code>and_masks</code> function, these three masks<label for="sd-note-that-the-causal" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sd-note-that-the-causal" class="margin-toggle"><span class="sidenote">Note that the causal mask is actually redundant to the sliding window mask, as the sliding window mask already ensures that tokens can only attend to previous tokens in the sequence. The causal mask is included here for clarity.</span> work together to create an efficient attention pattern that respects document boundaries, maintains causality, and limits computational overhead for long sequences.</p><p>After incorporating FlexAttention with these masks, and increasing our sequence length to 32768 tokens, we observe a massive speedup<label for="sd-this-speedup-is-a" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sd-this-speedup-is-a" class="margin-toggle"><span class="sidenote">This speedup is a bit of a hack against the target metric. Supporting longer sequences is a straightforward way to drop the loss on the validation set, but is unlikely to provide a meaningful improvement to the overall performance of the model on practical benchmarks.</span>. The new run time is <strong>2.55 hours</strong>, requiring only 1.88B tokens (a huge data-efficiency improvement). Our throughput dropped slightly to ~205k tokens/second. See commit <a href="https://github.com/tyler-romero/nanogpt-speedrun/commit/d982ed5900922e43a266c5d671b88f36efe72aaf"><code>d982ed5</code></a> for the full details.</p><p><picture><source type="image/webp" srcset="/assets/img/PBvDQRx2tZ-300.webp 300w, /assets/img/PBvDQRx2tZ-600.webp 600w, /assets/img/PBvDQRx2tZ-900.webp 900w, /assets/img/PBvDQRx2tZ-2562.webp 2562w" sizes="(max-width: 900px) 100vw, 900px"><img loading="lazy" decoding="async" class="responsive-image" src="/assets/img/PBvDQRx2tZ-300.png" alt="Section 3 loss plot" width="2562" height="1612" srcset="/assets/img/PBvDQRx2tZ-300.png 300w, /assets/img/PBvDQRx2tZ-600.png 600w, /assets/img/PBvDQRx2tZ-900.png 900w, /assets/img/PBvDQRx2tZ-2562.png 2562w" sizes="(max-width: 900px) 100vw, 900px"></picture></p></section>
<section><h2 id="references">References</h2><textarea id="bibtex_input" style="display:none;">
@misc{modded_nanogpt_2024,
  author       = {Keller Jordan and Jeremy Bernstein and Brendan Rappazzo and
                  @fernbear.bsky.social and Boza Vlado and You Jiacheng and
                  Franz Cesista and Braden Koszarsky and @Grad62304977},
  title        = {modded-nanogpt: Speedrunning the NanoGPT baseline},
  year         = {2024},
  url          = {https://github.com/KellerJordan/modded-nanogpt},
  note = {GitHub repository}
}
@software{hlb-gpt_2024,
  author={Fern},
  month={3},
  year = {2024},
  title={hlb-gpt},
  url={https://github.com/tysam-code/hlb-gpt},
  version = {0.4.0},
  note = {GitHub repository}
}
@misc{su2023roformerenhancedtransformerrotary,
      title={RoFormer: Enhanced Transformer with Rotary Position Embedding},
      author={Jianlin Su and Yu Lu and Shengfeng Pan and Ahmed Murtadha and Bo Wen and Yunfeng Liu},
      year={2023},
      eprint={2104.09864},
      archivePrefix={arXiv},
      primaryClass={cs.CL},
      url={https://arxiv.org/abs/2104.09864},
}
@misc{so2022primersearchingefficienttransformers,
      title={Primer: Searching for Efficient Transformers for Language Modeling},
      author={David R. So and Wojciech Mańke and Hanxiao Liu and Zihang Dai and Noam Shazeer and Quoc V. Le},
      year={2022},
      eprint={2109.08668},
      archivePrefix={arXiv},
      primaryClass={cs.LG},
      url={https://arxiv.org/abs/2109.08668},
}
@misc{hagele2024scalinglawscomputeoptimaltraining,
      title={Scaling Laws and Compute-Optimal Training Beyond Fixed Training Durations},
      author={Alexander Hägele and Elie Bakouch and Atli Kosson and Loubna Ben Allal and Leandro Von Werra and Martin Jaggi},
      year={2024},
      eprint={2405.18392},
      archivePrefix={arXiv},
      primaryClass={cs.LG},
      url={https://arxiv.org/abs/2405.18392},
}
@misc{hoffmann2022trainingcomputeoptimallargelanguage,
      title={Training Compute-Optimal Large Language Models},
      author={Jordan Hoffmann and Sebastian Borgeaud and Arthur Mensch and Elena Buchatskaya and Trevor Cai and Eliza Rutherford and Diego de Las Casas and Lisa Anne Hendricks and Johannes Welbl and Aidan Clark and Tom Hennigan and Eric Noland and Katie Millican and George van den Driessche and Bogdan Damoc and Aurelia Guy and Simon Osindero and Karen Simonyan and Erich Elsen and Jack W. Rae and Oriol Vinyals and Laurent Sifre},
      year={2022},
      eprint={2203.15556},
      archivePrefix={arXiv},
      primaryClass={cs.CL},
      url={https://arxiv.org/abs/2203.15556},
}
@misc{jordan2024muon,
  author       = {Keller Jordan and Yuchen Jin and Vlado Boza and Jiacheng You and
                  Franz Cesista and Laker Newhouse and Jeremy Bernstein},
  title        = {Muon: An optimizer for hidden layers in neural networks},
  year         = {2024},
  url          = {https://web.archive.org/web/20250122060345/https://kellerjordan.github.io/posts/muon/}
}
@misc{gupta2018shampoopreconditionedstochastictensor,
      title={Shampoo: Preconditioned Stochastic Tensor Optimization},
      author={Vineet Gupta and Tomer Koren and Yoram Singer},
      year={2018},
      eprint={1802.09568},
      archivePrefix={arXiv},
      primaryClass={cs.LG},
      url={https://arxiv.org/abs/1802.09568},
}
@misc{bernstein2024oldoptimizernewnorm,
      title={Old Optimizer, New Norm: An Anthology},
      author={Jeremy Bernstein and Laker Newhouse},
      year={2024},
      eprint={2409.20325},
      archivePrefix={arXiv},
      primaryClass={cs.LG},
      url={https://arxiv.org/abs/2409.20325},
}
@misc{gemmateam2024gemma2improvingopen,
      title={Gemma 2: Improving Open Language Models at a Practical Size},
      author={Gemma Team and Morgane Riviere and Shreya Pathak and Pier Giuseppe Sessa and Cassidy Hardin and Surya Bhupatiraju and Léonard Hussenot and Thomas Mesnard and Bobak Shahriari and Alexandre Ramé and Johan Ferret and Peter Liu and Pouya Tafti and Abe Friesen and Michelle Casbon and Sabela Ramos and Ravin Kumar and Charline Le Lan and Sammy Jerome and Anton Tsitsulin and Nino Vieillard and Piotr Stanczyk and Sertan Girgin and Nikola Momchev and Matt Hoffman and Shantanu Thakoor and Jean-Bastien Grill and Behnam Neyshabur and Olivier Bachem and Alanna Walton and Aliaksei Severyn and Alicia Parrish and Aliya Ahmad and Allen Hutchison and Alvin Abdagic and Amanda Carl and Amy Shen and Andy Brock and Andy Coenen and Anthony Laforge and Antonia Paterson and Ben Bastian and Bilal Piot and Bo Wu and Brandon Royal and Charlie Chen and Chintu Kumar and Chris Perry and Chris Welty and Christopher A. Choquette-Choo and Danila Sinopalnikov and David Weinberger and Dimple Vijaykumar and Dominika Rogozińska and Dustin Herbison and Elisa Bandy and Emma Wang and Eric Noland and Erica Moreira and Evan Senter and Evgenii Eltyshev and Francesco Visin and Gabriel Rasskin and Gary Wei and Glenn Cameron and Gus Martins and Hadi Hashemi and Hanna Klimczak-Plucińska and Harleen Batra and Harsh Dhand and Ivan Nardini and Jacinda Mein and Jack Zhou and James Svensson and Jeff Stanway and Jetha Chan and Jin Peng Zhou and Joana Carrasqueira and Joana Iljazi and Jocelyn Becker and Joe Fernandez and Joost van Amersfoort and Josh Gordon and Josh Lipschultz and Josh Newlan and Ju-yeong Ji and Kareem Mohamed and Kartikeya Badola and Kat Black and Katie Millican and Keelin McDonell and Kelvin Nguyen and Kiranbir Sodhia and Kish Greene and Lars Lowe Sjoesund and Lauren Usui and Laurent Sifre and Lena Heuermann and Leticia Lago and Lilly McNealus and Livio Baldini Soares and Logan Kilpatrick and Lucas Dixon and Luciano Martins and Machel Reid and Manvinder Singh and Mark Iverson and Martin Görner and Mat Velloso and Mateo Wirth and Matt Davidow and Matt Miller and Matthew Rahtz and Matthew Watson and Meg Risdal and Mehran Kazemi and Michael Moynihan and Ming Zhang and Minsuk Kahng and Minwoo Park and Mofi Rahman and Mohit Khatwani and Natalie Dao and Nenshad Bardoliwalla and Nesh Devanathan and Neta Dumai and Nilay Chauhan and Oscar Wahltinez and Pankil Botarda and Parker Barnes and Paul Barham and Paul Michel and Pengchong Jin and Petko Georgiev and Phil Culliton and Pradeep Kuppala and Ramona Comanescu and Ramona Merhej and Reena Jana and Reza Ardeshir Rokni and Rishabh Agarwal and Ryan Mullins and Samaneh Saadat and Sara Mc Carthy and Sarah Cogan and Sarah Perrin and Sébastien M. R. Arnold and Sebastian Krause and Shengyang Dai and Shruti Garg and Shruti Sheth and Sue Ronstrom and Susan Chan and Timothy Jordan and Ting Yu and Tom Eccles and Tom Hennigan and Tomas Kocisky and Tulsee Doshi and Vihan Jain and Vikas Yadav and Vilobh Meshram and Vishal Dharmadhikari and Warren Barkley and Wei Wei and Wenming Ye and Woohyun Han and Woosuk Kwon and Xiang Xu and Zhe Shen and Zhitao Gong and Zichuan Wei and Victor Cotruta and Phoebe Kirk and Anand Rao and Minh Giang and Ludovic Peran and Tris Warkentin and Eli Collins and Joelle Barral and Zoubin Ghahramani and Raia Hadsell and D. Sculley and Jeanine Banks and Anca Dragan and Slav Petrov and Oriol Vinyals and Jeff Dean and Demis Hassabis and Koray Kavukcuoglu and Clement Farabet and Elena Buchatskaya and Sebastian Borgeaud and Noah Fiedel and Armand Joulin and Kathleen Kenealy and Robert Dadashi and Alek Andreev},
      year={2024},
      eprint={2408.00118},
      archivePrefix={arXiv},
      primaryClass={cs.CL},
      url={https://arxiv.org/abs/2408.00118},
}
@misc{dong2024flexattentionprogrammingmodel,
      title={Flex Attention: A Programming Model for Generating Optimized Attention Kernels},
      author={Juechu Dong and Boyuan Feng and Driss Guessous and Yanbo Liang and Horace He},
      year={2024},
      eprint={2412.05496},
      archivePrefix={arXiv},
      primaryClass={cs.LG},
      url={https://arxiv.org/abs/2412.05496},
}
@misc{bernstein2025deriving,
  author = {Jeremy Bernstein},
  title = {Deriving Muon},
  url = {https://jeremybernste.in/writing/deriving-muon},
  year = {2025}
}</textarea>
<div id="bibtex_display"></div></section>

        </article>
        <footer>
            <footer>
    <hr class="slender">
    <p class="social-links">
        <a href="/"><span class="fas fa-home"></span></a>
        &nbsp
        <a href="https://twitter.com/tyleraromero"><i class="fab fa-twitter-square"></i></a>
        <a href="https://github.com/tyler-romero"><i class="fab fa-github-square"></i></a>
        <a href="https://linkedin.com/in/tylerromero"><i class="fab fa-linkedin"></i></a>
        <a href="mailto:tyler.alexander.romero+site@gmail.com"><i class="fas fa-envelope-square"></i></a>
        &nbsp
        <a href="/feed.xml"><i class="fas fa-rss-square"></i></a>
    </p>
    <p class="copyright" style="font-size: 1.0em;">&copy; 2025 Tyler Romero</p>
</footer>

        </footer>
    </body>
</html>
